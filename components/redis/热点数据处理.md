# 热点问题处理
## 雪崩
造成雪崩的主要原因在于同一时间有大面积的key过期失效，当流量集中爆发时，请求都会打到数据库上，造成系统雪崩。解决方案也比较简单：

- 热点数据设置永不过期
- 错峰过期，让key随机过期
```shell
setRedis（Key，value，time + Math.random() * 10000）；
```

- 提前预热，在大促前触发所有缓存数据
## 击穿
缓存穿透是指流量并发访问了一个过期的或者不存在的key。这样每个请求都会去访问到数据库上。缓存击穿是针对单个key来说的，而缓存雪崩是大面积key失效来说的，有点相似但角度不同。对应的解决办法是：

- 使用互斥锁，实现串行查询数据库，在数据没有准备好之前其他请求阻塞等待，会影响吞吐量。
## 穿透
通常是指在恶意攻击下，每次访问的key都是不存在且随机改变的。

- 加一个默认值，对于不存在的key我们可以分配一个默认值或者null都行。主要这种key要设置过期时间，避免内存浪费问题。
- 使用布隆过滤器
> 布隆过滤器：本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 **“某样东西一定不存在或者可能存在”**。相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。
> **对于可能存在的值是有概率性的，并不完全准确。Guava工具类中提供了**BloomFilter实现入口。

- 自定义过滤器，需要根据具体业务设置一些拦截条件。优点是过滤准确性更高，缺点是需要客户端感知业务，动态扩展不够灵活。
## 总结
### 事前

- 做好缓存预热，提前初始化好对应缓存。
- 可以将热点缓存数据拉去到本地，通过本地内存你来失效高效访问。定期刷新。
- 设置错峰过期失效
- 热点key可以永久有效
- 通过集群或者哨兵模式保证集群高可用
### 事中

- 通过互斥锁控制击穿场景访问数据库的并发量
- 使用熔断机制快速失败，保住部分交易。
- 限流、路由
### 事后

- 开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据


