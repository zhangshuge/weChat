
# 调优
## 客户端使用层面
### 合理使用数据结构
### 合理设计key


## 服务端运维层面
### 解决慢查询
Redis使用了一个列表来存储慢查询日志，即先进先出的队列。默认情况下慢查询列表会保存在内存中，这样当队列满了之后，会把最早记录的数据移除，也就是会丢失一起慢查询记录，可以通过配置将其写入磁盘。
慢查询只记录命令执行时间，并不包括命令排队和网络传输时间。通常应对慢查询有以下两种应对措施：

- 修改为地算法的命令，如hgetall改为hmget等，禁用keys（用scan替换）、sort等命令。
- 调整大对象：缩减大对象或将大对象按照不同维度拆分成多个小对象，避免一次命令操作过多的数据。



### 合理实现复制
1、可以使用树形拓步结构进行主备复制，避免同时有多个从节点从主节点复制数据。使用2.8以后版本提供的部分复制功能，用以应对初始全量复制阶段异常后的重试场景。
2、合理的设置缓冲区大小，因为主节点在生产RDB快照时，会把这一时间内持续操作的命令数据写入缓冲区，只有从节点加载完RDB后，主节点才会把缓冲区的数据发给从节点，保证主从之间的数据一致性。如果主节点创建和传输RDB的时间过长，对于高流量写入场景非常容易造成主节点复制客户端缓冲区溢出。还有一种情况就是如果从节点故障恢复后再次申请增量复制，但是由于其偏移量已经超出了缓冲区范围，这时增量复制就会退化为全量复制。
3、使用异步方式复制，这种方式可以提升整体性能但是也存在主从数据有延迟的问题。
4、业务低峰期间触发
5、Redis节点尽量打散到不同机器上，避免同一台机器上部署多个节点同时出发复制，导致资源竞争。
### 持久化阻塞
对于开启了持久化功能的Redis节点，持久化引起主线程阻塞的操作主要有：

- fork阻塞

fork操作发生在RDB和AOF重写时，主进程调用fork操作产生共享内存的子进程，如果fork本身耗时过长必然会导致主线程阻塞。以下四种解决方法供其参考：

1. 优先使用物理机或者高效支持fork操作的虚拟化技术，避免使用Xen.
1. 由于fork操作和内存大小成正比，所以需要控制Redis实例最大可用内存。
1. 合理配置Linux内存分配策略，避免物理内存不足导致fork失败。
1. 降低fork操作频率，如湿度放宽fork自动触发时机，避免不必要的全量复制等。
- AOF刷盘阻塞
- HugePage写操作阻塞

子进程在执行重新期间利用Linux写时复制技术（大内存分配）降低内存开销，因此只有写操作时Redis才复制要修改的内存页。THP默认是开启的，开启时可以加快fork子进程的速度，但fork操作之后，每个内存页从4K编程2M会大幅增加重新期间父进程的内存消耗，拖慢写操作的执行时间，导致大量写操作慢查询。
# 案例场景分析
包括业务案例场景和系统运维场景。
## 读写分离
读写分离其核心是通过分流读取从节点数据，从而降低主节点的压力。为了保证数据的一致性，从节点通常为只读模式。读写分离也存在三大弊端：
### 数据延迟
Redis赋值数据的延迟由于异步赋值特性是无法避免的，延迟取决于网络带宽和命令阻塞情况。该场景需要业务上允许短时间内的数据延迟才行，对于过期时间较短的数据不宜做读写分离。通常解决数据延迟的方法有3种：

- 客户端需要支持重复度，当从节点没有获取到数据的时候可以切换到主节点读取数据，需要客户端感知并改造其对应的重复读功能。
- 底层数据源可以容忍缓存数据被击穿，即从节点没有读到数据的时候，可以接受直接读取底层数据库。
- 旁路挂载一个监控系统，用于监控主从之间的偏移量变化，通过设置可接受的数据延迟范围来触发告警能力，超过延迟范围后通知客户端切回主节点，偏移量恢复到可接受范围后再同步客户端切回从节点。这种方式成本太大，不建议使用。
### 读到过期数据
由于“惰性删除”的特点，主节点只有在key过期后再次被调用的时候才会清除并同步给从节点，那再次期间从节点上被读取的数据都是超时的。该场景已经在Redis 3.2以后的版本得到了解决，即每次从节点读取数据之前会检查key的过期时间来决定是否返回数据。
### 从节点故障
如果从节点故障需要客户端维护一套节点列表，可以感知并切换到其他从节点或者主节点。因为主从不支持动态容错，需要人工接入，建议生产环境直接上cluster模式。
